// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/99designs/gqlgen/plugin/federation/fedruntime"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/Jurupoc/PriceAgregator/api-gateway/graph/model"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Price struct {
		PriceUSD  func(childComplexity int) int
		Source    func(childComplexity int) int
		Symbol    func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	Query struct {
		Prices func(childComplexity int) int
	}
}

type QueryResolver interface {
	Prices(ctx context.Context) ([]*model.Price, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return generatedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, nil, nil}
	_ = ec
	switch typeName + "." + field {

	case "Price.priceUSD":
		if e.complexity.Price.PriceUSD == nil {
			break
		}

		return e.complexity.Price.PriceUSD(childComplexity), true

	case "Price.source":
		if e.complexity.Price.Source == nil {
			break
		}

		return e.complexity.Price.Source(childComplexity), true

	case "Price.symbol":
		if e.complexity.Price.Symbol == nil {
			break
		}

		return e.complexity.Price.Symbol(childComplexity), true

	case "Price.timestamp":
		if e.complexity.Price.Timestamp == nil {
			break
		}

		return e.complexity.Price.Timestamp(childComplexity), true

	case "Query.prices":
		if e.complexity.Query.Prices == nil {
			break
		}

		return e.complexity.Query.Prices(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, nil, nil}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	index  int
	field  field
	fields []field
}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "prices":
			field := field

			innerCtx := graphql.WithOperationContext(ctx, &graphql.OperationContext{
				Index:  &field.Index,
				Result: &graphql.Response{Data: graphql.GetOperationContext(ctx).Doc.Operations[0].SelectionSet},
			})
			out.Values[i] = ec._Query_prices(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	return out
}

func (ec *executionContext) _Query_prices(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
		Field:  field,
	})
	resTmp := ec._fieldMiddleware(ctx, nil, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Query().Prices(ctx)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Price)
	fc := graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context) (*graphql.FieldContext, error) {
			return nil, nil
		},
	}
	return graphql.WithFieldContext(ctx, &fc)
	resArr1 := graphql.Array{}
	for idx1 := range res {
		resArr1 = append(resArr1, func() graphql.Marshaler {
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._Price(ctx, field.Selections, res[idx1])
		}())
	}
	return resArr1
}

func (ec *executionContext) _Price(ctx context.Context, sel ast.SelectionSet, obj *model.Price) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, priceImplementors)
	out := graphql.NewFieldSet(fields)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Price")
		case "symbol":
			out.Values[i] = ec._Price_symbol(ctx, field, obj)
		case "priceUSD":
			out.Values[i] = ec._Price_priceUSD(ctx, field, obj)
		case "source":
			out.Values[i] = ec._Price_source(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._Price_timestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	return out
}

func (ec *executionContext) _Price_symbol(ctx context.Context, field graphql.CollectedField, obj *model.Price) graphql.Marshaler {
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Price",
		Field:  field,
	})
	rctx := &graphql.ResolverContext{
		Object: "Price",
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	return graphql.MarshalString(obj.Symbol)
}

func (ec *executionContext) _Price_priceUSD(ctx context.Context, field graphql.CollectedField, obj *model.Price) graphql.Marshaler {
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Price",
		Field:  field,
	})
	rctx := &graphql.ResolverContext{
		Object: "Price",
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	return graphql.MarshalFloat(obj.PriceUSD)
}

func (ec *executionContext) _Price_source(ctx context.Context, field graphql.CollectedField, obj *model.Price) graphql.Marshaler {
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Price",
		Field:  field,
	})
	rctx := &graphql.ResolverContext{
		Object: "Price",
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	return graphql.MarshalString(obj.Source)
}

func (ec *executionContext) _Price_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.Price) graphql.Marshaler {
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Price",
		Field:  field,
	})
	rctx := &graphql.ResolverContext{
		Object: "Price",
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	return graphql.MarshalString(obj.Timestamp)
}

var (
	queryImplementors = []string{"Query"}
	priceImplementors = []string{"Price"}
)

type field struct {
	name  string
	field *ast.Field
}

func (ec *executionContext) _fieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}, err error) {
	fc := graphql.GetFieldContext(ctx)
	for _, d := range fc.Field.Directives {
		switch d.Name {
		}
	}
	return next(ctx)
}

//go:embed "schema.graphqls"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema.graphqls", Input: sourceData("schema.graphqls"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

var generatedSchema = parsedSchema

